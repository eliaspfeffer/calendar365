-- Public calendar shares with optional password protection

-- Supabase typically installs extensions into the `extensions` schema.
CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;

CREATE TABLE IF NOT EXISTS public.calendar_public_shares (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  calendar_id UUID NOT NULL REFERENCES public.calendars(id) ON DELETE CASCADE,
  slug TEXT NOT NULL,
  password_hash TEXT NULL,
  created_by UUID NULL REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  revoked_at TIMESTAMP WITH TIME ZONE NULL
);

ALTER TABLE public.calendar_public_shares
  DROP CONSTRAINT IF EXISTS calendar_public_shares_slug_format;

ALTER TABLE public.calendar_public_shares
  ADD CONSTRAINT calendar_public_shares_slug_format
  CHECK (
    char_length(slug) BETWEEN 3 AND 64
    AND slug ~ '^[a-z0-9](?:[a-z0-9-]{1,62}[a-z0-9])?$'
  );

CREATE UNIQUE INDEX IF NOT EXISTS idx_calendar_public_shares_active_slug
  ON public.calendar_public_shares(slug)
  WHERE revoked_at IS NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_calendar_public_shares_active_calendar
  ON public.calendar_public_shares(calendar_id)
  WHERE revoked_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_calendar_public_shares_calendar_id ON public.calendar_public_shares(calendar_id);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_trigger
    WHERE tgname = 'update_calendar_public_shares_updated_at'
  ) THEN
    CREATE TRIGGER update_calendar_public_shares_updated_at
    BEFORE UPDATE ON public.calendar_public_shares
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
  END IF;
END $$;

CREATE TABLE IF NOT EXISTS public.calendar_public_share_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  share_id UUID NOT NULL REFERENCES public.calendar_public_shares(id) ON DELETE CASCADE,
  attempted_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  ip_hash BYTEA NULL,
  success BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE INDEX IF NOT EXISTS idx_calendar_public_share_attempts_share_time
  ON public.calendar_public_share_attempts(share_id, attempted_at DESC);
CREATE INDEX IF NOT EXISTS idx_calendar_public_share_attempts_share_ip_time
  ON public.calendar_public_share_attempts(share_id, ip_hash, attempted_at DESC);

ALTER TABLE public.calendar_public_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.calendar_public_share_attempts ENABLE ROW LEVEL SECURITY;

-- No direct table access; use RPC only.

CREATE OR REPLACE FUNCTION public._public_share_request_ip()
RETURNS TEXT
LANGUAGE sql
STABLE
AS $$
  SELECT NULLIF(
    btrim(split_part(
      coalesce(
        current_setting('request.header.x-forwarded-for', true),
        current_setting('request.header.x-real-ip', true),
        current_setting('request.header.cf-connecting-ip', true),
        ''
      ),
      ',',
      1
    )),
    ''
  );
$$;

REVOKE ALL ON FUNCTION public._public_share_request_ip() FROM PUBLIC;

CREATE OR REPLACE FUNCTION public._normalize_public_share_slug(p_slug TEXT)
RETURNS TEXT
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT regexp_replace(
    regexp_replace(lower(btrim(coalesce(p_slug, ''))), '[^a-z0-9-]+', '-', 'g'),
    '(^-+)|(-+$)',
    '',
    'g'
  );
$$;

REVOKE ALL ON FUNCTION public._normalize_public_share_slug(TEXT) FROM PUBLIC;

CREATE OR REPLACE FUNCTION public.get_calendar_public_share_settings(p_calendar_id UUID)
RETURNS TABLE (slug TEXT, has_password BOOLEAN, is_enabled BOOLEAN)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM public.calendar_members m
    WHERE m.calendar_id = p_calendar_id
      AND m.user_id = auth.uid()
      AND m.role IN ('owner', 'editor')
  ) THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  RETURN QUERY
  SELECT s.slug, (s.password_hash IS NOT NULL) AS has_password, (s.revoked_at IS NULL) AS is_enabled
  FROM public.calendar_public_shares s
  WHERE s.calendar_id = p_calendar_id
    AND s.revoked_at IS NULL
  LIMIT 1;
END;
$$;

REVOKE ALL ON FUNCTION public.get_calendar_public_share_settings(UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_calendar_public_share_settings(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.set_calendar_public_share(
  p_calendar_id UUID,
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_remove_password BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (slug TEXT, has_password BOOLEAN)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
  next_hash TEXT;
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM public.calendar_members m
    WHERE m.calendar_id = p_calendar_id
      AND m.user_id = auth.uid()
      AND m.role IN ('owner', 'editor')
  ) THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  safe_slug := public._normalize_public_share_slug(p_slug);
  IF safe_slug IS NULL OR safe_slug = '' THEN
    RAISE EXCEPTION 'invalid slug';
  END IF;

  IF char_length(safe_slug) < 3 OR char_length(safe_slug) > 64 OR safe_slug !~ '^[a-z0-9](?:[a-z0-9-]{1,62}[a-z0-9])?$' THEN
    RAISE EXCEPTION 'invalid slug';
  END IF;

  IF p_remove_password THEN
    next_hash := NULL;
  ELSIF p_password IS NULL OR btrim(p_password) = '' THEN
    next_hash := NULL; -- keep as-is on update via COALESCE below
  ELSE
    next_hash := extensions.crypt(p_password, extensions.gen_salt('bf', 10));
  END IF;

  BEGIN
    INSERT INTO public.calendar_public_shares (calendar_id, slug, password_hash, created_by)
    VALUES (p_calendar_id, safe_slug, CASE WHEN next_hash IS NULL AND NOT p_remove_password THEN NULL ELSE next_hash END, auth.uid())
    ON CONFLICT (calendar_id) WHERE revoked_at IS NULL
    DO UPDATE SET
      slug = EXCLUDED.slug,
      password_hash = CASE
        WHEN p_remove_password THEN NULL
        WHEN next_hash IS NULL THEN public.calendar_public_shares.password_hash
        ELSE next_hash
      END,
      updated_at = now()
    RETURNING public.calendar_public_shares.slug, (public.calendar_public_shares.password_hash IS NOT NULL) AS has_password
    INTO slug, has_password;
  EXCEPTION
    WHEN unique_violation THEN
      RAISE EXCEPTION 'slug already in use';
  END;

  RETURN NEXT;
END;
$$;

REVOKE ALL ON FUNCTION public.set_calendar_public_share(UUID, TEXT, TEXT, BOOLEAN) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.set_calendar_public_share(UUID, TEXT, TEXT, BOOLEAN) TO authenticated;

CREATE OR REPLACE FUNCTION public.revoke_calendar_public_share(p_calendar_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM public.calendar_members m
    WHERE m.calendar_id = p_calendar_id
      AND m.user_id = auth.uid()
      AND m.role IN ('owner', 'editor')
  ) THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  UPDATE public.calendar_public_shares
  SET revoked_at = now()
  WHERE calendar_id = p_calendar_id
    AND revoked_at IS NULL;

  RETURN FOUND;
END;
$$;

REVOKE ALL ON FUNCTION public.revoke_calendar_public_share(UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.revoke_calendar_public_share(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_public_calendar_share_info(p_slug TEXT)
RETURNS TABLE (calendar_name TEXT, requires_password BOOLEAN)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
BEGIN
  safe_slug := public._normalize_public_share_slug(p_slug);
  IF safe_slug IS NULL OR safe_slug = '' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT c.name, (s.password_hash IS NOT NULL) AS requires_password
  FROM public.calendar_public_shares s
  JOIN public.calendars c ON c.id = s.calendar_id
  WHERE s.slug = safe_slug
    AND s.revoked_at IS NULL
  LIMIT 1;
END;
$$;

REVOKE ALL ON FUNCTION public.get_public_calendar_share_info(TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_public_calendar_share_info(TEXT) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.get_public_calendar_share_snapshot(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
  share_row public.calendar_public_shares%ROWTYPE;
  cal_name TEXT;
  ip TEXT;
  v_ip_hash BYTEA;
  failed_count INT;
BEGIN
  safe_slug := public._normalize_public_share_slug(p_slug);
  IF safe_slug IS NULL OR safe_slug = '' THEN
    RAISE EXCEPTION 'not found';
  END IF;

  SELECT *
  INTO share_row
  FROM public.calendar_public_shares s
  WHERE s.slug = safe_slug
    AND s.revoked_at IS NULL
  LIMIT 1;

  IF share_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  IF share_row.password_hash IS NOT NULL THEN
    ip := public._public_share_request_ip();
    IF ip IS NOT NULL THEN
      v_ip_hash := extensions.digest(ip || '|' || share_row.id::TEXT, 'sha256');
    ELSE
      v_ip_hash := NULL;
    END IF;

    SELECT count(*)::INT
    INTO failed_count
    FROM public.calendar_public_share_attempts a
    WHERE a.share_id = share_row.id
      AND (v_ip_hash IS NULL OR a.ip_hash = v_ip_hash)
      AND a.success = FALSE
      AND a.attempted_at > now() - interval '15 minutes';

    IF failed_count >= 10 THEN
      RAISE EXCEPTION 'too many attempts';
    END IF;

    IF p_password IS NULL OR extensions.crypt(p_password, share_row.password_hash) <> share_row.password_hash THEN
      INSERT INTO public.calendar_public_share_attempts (share_id, ip_hash, success)
      VALUES (share_row.id, v_ip_hash, FALSE);
      RAISE EXCEPTION 'invalid password';
    END IF;

    INSERT INTO public.calendar_public_share_attempts (share_id, ip_hash, success)
    VALUES (share_row.id, v_ip_hash, TRUE);
  END IF;

  SELECT c.name INTO cal_name
  FROM public.calendars c
  WHERE c.id = share_row.calendar_id
  LIMIT 1;

  RETURN jsonb_build_object(
    'calendar', jsonb_build_object('id', share_row.calendar_id, 'name', cal_name),
    'notes', coalesce((
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', n.id,
          'calendar_id', n.calendar_id,
          'user_id', n.user_id,
          'date', n.date,
          'text', n.text,
          'color', n.color,
          'pos_x', n.pos_x,
          'pos_y', n.pos_y
        )
        ORDER BY n.created_at ASC
      )
      FROM public.sticky_notes n
      WHERE n.calendar_id = share_row.calendar_id
    ), '[]'::jsonb),
    'connections', coalesce((
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', c.id,
          'calendar_id', c.calendar_id,
          'user_id', c.user_id,
          'source_note_id', c.source_note_id,
          'target_note_id', c.target_note_id
        )
        ORDER BY c.created_at ASC
      )
      FROM public.note_connections c
      WHERE c.calendar_id = share_row.calendar_id
    ), '[]'::jsonb)
  );
END;
$$;

REVOKE ALL ON FUNCTION public.get_public_calendar_share_snapshot(TEXT, TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_public_calendar_share_snapshot(TEXT, TEXT) TO anon, authenticated;
