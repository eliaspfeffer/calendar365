-- Public share links v2: multiple links, per-link permissions, multi-calendar scope, and optional password.

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;

-- New tables
CREATE TABLE IF NOT EXISTS public.public_share_links (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  slug TEXT NOT NULL,
  permission public.calendar_member_role NOT NULL DEFAULT 'viewer',
  password_hash TEXT NULL,
  created_by UUID NULL REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  revoked_at TIMESTAMP WITH TIME ZONE NULL
);

ALTER TABLE public.public_share_links
  DROP CONSTRAINT IF EXISTS public_share_links_slug_format;
ALTER TABLE public.public_share_links
  ADD CONSTRAINT public_share_links_slug_format
  CHECK (
    char_length(slug) BETWEEN 3 AND 64
    AND slug ~ '^[a-z0-9](?:[a-z0-9-]{1,62}[a-z0-9])?$'
  );

ALTER TABLE public.public_share_links
  DROP CONSTRAINT IF EXISTS public_share_links_permission_allowed;
ALTER TABLE public.public_share_links
  ADD CONSTRAINT public_share_links_permission_allowed
  CHECK (permission IN ('viewer', 'editor'));

CREATE UNIQUE INDEX IF NOT EXISTS idx_public_share_links_active_slug
  ON public.public_share_links(slug)
  WHERE revoked_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_public_share_links_created_by ON public.public_share_links(created_by);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_trigger
    WHERE tgname = 'update_public_share_links_updated_at'
  ) THEN
    CREATE TRIGGER update_public_share_links_updated_at
    BEFORE UPDATE ON public.public_share_links
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
  END IF;
END $$;

CREATE TABLE IF NOT EXISTS public.public_share_link_calendars (
  share_link_id UUID NOT NULL REFERENCES public.public_share_links(id) ON DELETE CASCADE,
  calendar_id UUID NOT NULL REFERENCES public.calendars(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  PRIMARY KEY (share_link_id, calendar_id)
);

CREATE INDEX IF NOT EXISTS idx_public_share_link_calendars_calendar_id
  ON public.public_share_link_calendars(calendar_id);

CREATE TABLE IF NOT EXISTS public.public_share_link_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  share_link_id UUID NOT NULL REFERENCES public.public_share_links(id) ON DELETE CASCADE,
  attempted_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  ip_hash BYTEA NULL,
  success BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE INDEX IF NOT EXISTS idx_public_share_link_attempts_share_time
  ON public.public_share_link_attempts(share_link_id, attempted_at DESC);
CREATE INDEX IF NOT EXISTS idx_public_share_link_attempts_share_ip_time
  ON public.public_share_link_attempts(share_link_id, ip_hash, attempted_at DESC);

ALTER TABLE public.public_share_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.public_share_link_calendars ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.public_share_link_attempts ENABLE ROW LEVEL SECURITY;

-- No direct table access; use RPC only.

-- Helpers
CREATE OR REPLACE FUNCTION public._validate_public_share_link_password(
  p_share_link_id UUID,
  p_password_hash TEXT,
  p_password TEXT
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  ip TEXT;
  v_ip_hash BYTEA;
  failed_count INT;
BEGIN
  IF p_password_hash IS NULL THEN
    RETURN;
  END IF;

  ip := public._public_share_request_ip();
  IF ip IS NOT NULL THEN
    v_ip_hash := extensions.digest(ip || '|' || p_share_link_id::TEXT, 'sha256');
  ELSE
    v_ip_hash := NULL;
  END IF;

  SELECT count(*)::INT
  INTO failed_count
  FROM public.public_share_link_attempts a
  WHERE a.share_link_id = p_share_link_id
    AND (v_ip_hash IS NULL OR a.ip_hash = v_ip_hash)
    AND a.success = FALSE
    AND a.attempted_at > now() - interval '15 minutes';

  IF failed_count >= 10 THEN
    RAISE EXCEPTION 'too many attempts';
  END IF;

  IF p_password IS NULL OR extensions.crypt(p_password, p_password_hash) <> p_password_hash THEN
    INSERT INTO public.public_share_link_attempts (share_link_id, ip_hash, success)
    VALUES (p_share_link_id, v_ip_hash, FALSE);
    RAISE EXCEPTION 'invalid password';
  END IF;

  INSERT INTO public.public_share_link_attempts (share_link_id, ip_hash, success)
  VALUES (p_share_link_id, v_ip_hash, TRUE);
END;
$$;

REVOKE ALL ON FUNCTION public._validate_public_share_link_password(UUID, TEXT, TEXT) FROM PUBLIC;

CREATE OR REPLACE FUNCTION public._assert_public_share_link_access(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_require_editor BOOLEAN DEFAULT FALSE
)
RETURNS public.public_share_links
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
  link_row public.public_share_links%ROWTYPE;
BEGIN
  safe_slug := public._normalize_public_share_slug(p_slug);
  IF safe_slug IS NULL OR safe_slug = '' THEN
    RAISE EXCEPTION 'not found';
  END IF;

  SELECT *
  INTO link_row
  FROM public.public_share_links l
  WHERE l.slug = safe_slug
    AND l.revoked_at IS NULL
  LIMIT 1;

  IF link_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._validate_public_share_link_password(link_row.id, link_row.password_hash, p_password);

  IF p_require_editor AND link_row.permission <> 'editor' THEN
    RAISE EXCEPTION 'view only';
  END IF;

  RETURN link_row;
END;
$$;

REVOKE ALL ON FUNCTION public._assert_public_share_link_access(TEXT, TEXT, BOOLEAN) FROM PUBLIC;

CREATE OR REPLACE FUNCTION public._assert_calendar_in_share_link(
  p_share_link_id UUID,
  p_calendar_id UUID
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM public.public_share_link_calendars sc
    WHERE sc.share_link_id = p_share_link_id
      AND sc.calendar_id = p_calendar_id
  ) THEN
    RAISE EXCEPTION 'not allowed';
  END IF;
END;
$$;

REVOKE ALL ON FUNCTION public._assert_calendar_in_share_link(UUID, UUID) FROM PUBLIC;

CREATE OR REPLACE FUNCTION public._public_share_actor_user_id(
  p_share_link_id UUID,
  p_calendar_id UUID
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_created_by UUID;
  v_owner_id UUID;
BEGIN
  SELECT l.created_by INTO v_created_by
  FROM public.public_share_links l
  WHERE l.id = p_share_link_id
  LIMIT 1;

  IF v_created_by IS NOT NULL THEN
    RETURN v_created_by;
  END IF;

  SELECT c.owner_id INTO v_owner_id
  FROM public.calendars c
  WHERE c.id = p_calendar_id
  LIMIT 1;

  IF v_owner_id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  RETURN v_owner_id;
END;
$$;

REVOKE ALL ON FUNCTION public._public_share_actor_user_id(UUID, UUID) FROM PUBLIC;

-- Creator management
CREATE OR REPLACE FUNCTION public.list_public_share_links(p_include_revoked BOOLEAN DEFAULT FALSE)
RETURNS TABLE (
  id UUID,
  slug TEXT,
  permission public.calendar_member_role,
  has_password BOOLEAN,
  created_at TIMESTAMP WITH TIME ZONE,
  revoked_at TIMESTAMP WITH TIME ZONE,
  calendars JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  RETURN QUERY
  SELECT
    l.id,
    l.slug,
    l.permission,
    (l.password_hash IS NOT NULL) AS has_password,
    l.created_at,
    l.revoked_at,
    coalesce((
      SELECT jsonb_agg(jsonb_build_object('id', c.id, 'name', c.name) ORDER BY c.name)
      FROM public.public_share_link_calendars sc
      JOIN public.calendars c ON c.id = sc.calendar_id
      WHERE sc.share_link_id = l.id
    ), '[]'::jsonb) AS calendars
  FROM public.public_share_links l
  WHERE l.created_by = auth.uid()
    AND (p_include_revoked OR l.revoked_at IS NULL)
  ORDER BY l.revoked_at NULLS FIRST, l.created_at DESC;
END;
$$;

REVOKE ALL ON FUNCTION public.list_public_share_links(BOOLEAN) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.list_public_share_links(BOOLEAN) TO authenticated;

CREATE OR REPLACE FUNCTION public.create_public_share_link(
  p_slug TEXT,
  p_permission public.calendar_member_role DEFAULT 'viewer',
  p_calendar_ids UUID[] DEFAULT NULL,
  p_password TEXT DEFAULT NULL
)
RETURNS TABLE (id UUID, slug TEXT, permission public.calendar_member_role, has_password BOOLEAN)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
  next_hash TEXT;
  cal_id UUID;
BEGIN
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  IF p_permission NOT IN ('viewer', 'editor') THEN
    RAISE EXCEPTION 'invalid permission';
  END IF;

  IF p_calendar_ids IS NULL OR array_length(p_calendar_ids, 1) IS NULL OR array_length(p_calendar_ids, 1) = 0 THEN
    RAISE EXCEPTION 'no calendars selected';
  END IF;

  safe_slug := public._normalize_public_share_slug(p_slug);
  IF safe_slug IS NULL OR safe_slug = '' THEN
    RAISE EXCEPTION 'invalid slug';
  END IF;
  IF char_length(safe_slug) < 3 OR char_length(safe_slug) > 64 OR safe_slug !~ '^[a-z0-9](?:[a-z0-9-]{1,62}[a-z0-9])?$' THEN
    RAISE EXCEPTION 'invalid slug';
  END IF;

  IF p_password IS NULL OR btrim(p_password) = '' THEN
    next_hash := NULL;
  ELSE
    next_hash := extensions.crypt(p_password, extensions.gen_salt('bf', 10));
  END IF;

  -- Ensure the creator has edit access to every selected calendar.
  FOREACH cal_id IN ARRAY p_calendar_ids LOOP
    IF NOT EXISTS (
      SELECT 1
      FROM public.calendar_members m
      WHERE m.calendar_id = cal_id
        AND m.user_id = auth.uid()
        AND m.role IN ('owner', 'editor')
    ) THEN
      RAISE EXCEPTION 'not allowed';
    END IF;
  END LOOP;

  BEGIN
    INSERT INTO public.public_share_links (slug, permission, password_hash, created_by)
    VALUES (safe_slug, p_permission, next_hash, auth.uid())
    RETURNING public.public_share_links.id, public.public_share_links.slug, public.public_share_links.permission, (public.public_share_links.password_hash IS NOT NULL) AS has_password
    INTO id, slug, permission, has_password;
  EXCEPTION
    WHEN unique_violation THEN
      RAISE EXCEPTION 'slug already in use';
  END;

  INSERT INTO public.public_share_link_calendars (share_link_id, calendar_id)
  SELECT id, x
  FROM unnest(p_calendar_ids) AS x;

  RETURN NEXT;
END;
$$;

REVOKE ALL ON FUNCTION public.create_public_share_link(TEXT, public.calendar_member_role, UUID[], TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.create_public_share_link(TEXT, public.calendar_member_role, UUID[], TEXT) TO authenticated;

CREATE OR REPLACE FUNCTION public.update_public_share_link(
  p_share_link_id UUID,
  p_slug TEXT DEFAULT NULL,
  p_permission public.calendar_member_role DEFAULT NULL,
  p_calendar_ids UUID[] DEFAULT NULL,
  p_password TEXT DEFAULT NULL,
  p_remove_password BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (id UUID, slug TEXT, permission public.calendar_member_role, has_password BOOLEAN, revoked_at TIMESTAMP WITH TIME ZONE)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
  next_hash TEXT;
  existing public.public_share_links%ROWTYPE;
  cal_id UUID;
BEGIN
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  SELECT *
  INTO existing
  FROM public.public_share_links l
  WHERE l.id = p_share_link_id
    AND l.created_by = auth.uid()
  LIMIT 1;

  IF existing.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  IF p_permission IS NOT NULL AND p_permission NOT IN ('viewer', 'editor') THEN
    RAISE EXCEPTION 'invalid permission';
  END IF;

  safe_slug := NULL;
  IF p_slug IS NOT NULL THEN
    safe_slug := public._normalize_public_share_slug(p_slug);
    IF safe_slug IS NULL OR safe_slug = '' THEN
      RAISE EXCEPTION 'invalid slug';
    END IF;
    IF char_length(safe_slug) < 3 OR char_length(safe_slug) > 64 OR safe_slug !~ '^[a-z0-9](?:[a-z0-9-]{1,62}[a-z0-9])?$' THEN
      RAISE EXCEPTION 'invalid slug';
    END IF;
  END IF;

  IF p_remove_password THEN
    next_hash := NULL;
  ELSIF p_password IS NULL OR btrim(p_password) = '' THEN
    next_hash := NULL; -- keep as-is on update via COALESCE below
  ELSE
    next_hash := extensions.crypt(p_password, extensions.gen_salt('bf', 10));
  END IF;

  IF p_calendar_ids IS NOT NULL THEN
    IF array_length(p_calendar_ids, 1) IS NULL OR array_length(p_calendar_ids, 1) = 0 THEN
      RAISE EXCEPTION 'no calendars selected';
    END IF;
    FOREACH cal_id IN ARRAY p_calendar_ids LOOP
      IF NOT EXISTS (
        SELECT 1
        FROM public.calendar_members m
        WHERE m.calendar_id = cal_id
          AND m.user_id = auth.uid()
          AND m.role IN ('owner', 'editor')
      ) THEN
        RAISE EXCEPTION 'not allowed';
      END IF;
    END LOOP;
  END IF;

  BEGIN
    UPDATE public.public_share_links l
    SET
      slug = COALESCE(safe_slug, l.slug),
      permission = COALESCE(p_permission, l.permission),
      password_hash = CASE
        WHEN p_remove_password THEN NULL
        WHEN next_hash IS NULL THEN l.password_hash
        ELSE next_hash
      END,
      updated_at = now()
    WHERE l.id = p_share_link_id
      AND l.created_by = auth.uid()
    RETURNING l.id, l.slug, l.permission, (l.password_hash IS NOT NULL) AS has_password, l.revoked_at
    INTO id, slug, permission, has_password, revoked_at;
  EXCEPTION
    WHEN unique_violation THEN
      RAISE EXCEPTION 'slug already in use';
  END;

  IF p_calendar_ids IS NOT NULL THEN
    DELETE FROM public.public_share_link_calendars sc
    WHERE sc.share_link_id = p_share_link_id;

    INSERT INTO public.public_share_link_calendars (share_link_id, calendar_id)
    SELECT p_share_link_id, x
    FROM unnest(p_calendar_ids) AS x;
  END IF;

  RETURN NEXT;
END;
$$;

REVOKE ALL ON FUNCTION public.update_public_share_link(UUID, TEXT, public.calendar_member_role, UUID[], TEXT, BOOLEAN) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.update_public_share_link(UUID, TEXT, public.calendar_member_role, UUID[], TEXT, BOOLEAN) TO authenticated;

CREATE OR REPLACE FUNCTION public.revoke_public_share_link(p_share_link_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  UPDATE public.public_share_links
  SET revoked_at = now()
  WHERE id = p_share_link_id
    AND created_by = auth.uid()
    AND revoked_at IS NULL;

  RETURN FOUND;
END;
$$;

REVOKE ALL ON FUNCTION public.revoke_public_share_link(UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.revoke_public_share_link(UUID) TO authenticated;

-- Public access (anon)
CREATE OR REPLACE FUNCTION public.get_public_share_link_info(p_slug TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  safe_slug TEXT;
  link_row public.public_share_links%ROWTYPE;
BEGIN
  safe_slug := public._normalize_public_share_slug(p_slug);
  IF safe_slug IS NULL OR safe_slug = '' THEN
    RETURN NULL;
  END IF;

  SELECT *
  INTO link_row
  FROM public.public_share_links l
  WHERE l.slug = safe_slug
    AND l.revoked_at IS NULL
  LIMIT 1;

  IF link_row.id IS NULL THEN
    RETURN NULL;
  END IF;

  RETURN jsonb_build_object(
    'slug', link_row.slug,
    'permission', link_row.permission,
    'requires_password', (link_row.password_hash IS NOT NULL),
    'calendars', coalesce((
      SELECT jsonb_agg(jsonb_build_object('id', c.id, 'name', c.name) ORDER BY c.name)
      FROM public.public_share_link_calendars sc
      JOIN public.calendars c ON c.id = sc.calendar_id
      WHERE sc.share_link_id = link_row.id
    ), '[]'::jsonb)
  );
END;
$$;

REVOKE ALL ON FUNCTION public.get_public_share_link_info(TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_public_share_link_info(TEXT) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.get_public_share_link_snapshot(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_calendar_ids UUID[] DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  selected_ids UUID[];
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, FALSE);

  IF p_calendar_ids IS NULL THEN
    SELECT array_agg(sc.calendar_id)
    INTO selected_ids
    FROM public.public_share_link_calendars sc
    WHERE sc.share_link_id = link_row.id;
  ELSE
    SELECT array_agg(sc.calendar_id)
    INTO selected_ids
    FROM public.public_share_link_calendars sc
    WHERE sc.share_link_id = link_row.id
      AND sc.calendar_id = ANY(p_calendar_ids);
  END IF;

  IF selected_ids IS NULL OR array_length(selected_ids, 1) IS NULL OR array_length(selected_ids, 1) = 0 THEN
    RAISE EXCEPTION 'not found';
  END IF;

  RETURN jsonb_build_object(
    'permission', link_row.permission,
    'calendars', coalesce((
      SELECT jsonb_agg(jsonb_build_object('id', c.id, 'name', c.name) ORDER BY c.name)
      FROM public.calendars c
      WHERE c.id = ANY(selected_ids)
    ), '[]'::jsonb),
    'notes', coalesce((
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', n.id,
          'calendar_id', n.calendar_id,
          'user_id', n.user_id,
          'date', NULLIF(n.date, ''),
          'text', n.text,
          'color', n.color,
          'is_struck', n.is_struck,
          'pos_x', n.pos_x,
          'pos_y', n.pos_y,
          'sort_order', n.sort_order,
          'created_at', n.created_at
        )
        ORDER BY n.created_at ASC
      )
      FROM public.sticky_notes n
      WHERE n.calendar_id = ANY(selected_ids)
    ), '[]'::jsonb),
    'connections', coalesce((
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', c.id,
          'calendar_id', c.calendar_id,
          'user_id', c.user_id,
          'source_note_id', c.source_note_id,
          'target_note_id', c.target_note_id,
          'created_at', c.created_at
        )
        ORDER BY c.created_at ASC
      )
      FROM public.note_connections c
      WHERE c.calendar_id = ANY(selected_ids)
    ), '[]'::jsonb)
  );
END;
$$;

REVOKE ALL ON FUNCTION public.get_public_share_link_snapshot(TEXT, TEXT, UUID[]) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_public_share_link_snapshot(TEXT, TEXT, UUID[]) TO anon, authenticated;

-- Public edit (requires editor)
CREATE OR REPLACE FUNCTION public.public_share_insert_sticky_note(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_calendar_id UUID,
  p_date TEXT DEFAULT NULL,
  p_text TEXT,
  p_color TEXT,
  p_pos_x DOUBLE PRECISION DEFAULT NULL,
  p_pos_y DOUBLE PRECISION DEFAULT NULL,
  p_sort_order INT DEFAULT NULL
)
RETURNS public.sticky_notes
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  actor_id UUID;
  note_row public.sticky_notes%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);
  PERFORM public._assert_calendar_in_share_link(link_row.id, p_calendar_id);
  actor_id := public._public_share_actor_user_id(link_row.id, p_calendar_id);

  INSERT INTO public.sticky_notes (
    user_id,
    calendar_id,
    date,
    text,
    color,
    pos_x,
    pos_y,
    sort_order
  )
  VALUES (
    actor_id,
    p_calendar_id,
    p_date,
    p_text,
    p_color,
    p_pos_x,
    p_pos_y,
    p_sort_order
  )
  RETURNING * INTO note_row;

  RETURN note_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_insert_sticky_note(TEXT, TEXT, UUID, TEXT, TEXT, TEXT, DOUBLE PRECISION, DOUBLE PRECISION, INT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_insert_sticky_note(TEXT, TEXT, UUID, TEXT, TEXT, TEXT, DOUBLE PRECISION, DOUBLE PRECISION, INT) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_update_sticky_note(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_note_id UUID,
  p_text TEXT,
  p_color TEXT
)
RETURNS public.sticky_notes
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  note_row public.sticky_notes%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT * INTO note_row
  FROM public.sticky_notes n
  WHERE n.id = p_note_id
  LIMIT 1;

  IF note_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, note_row.calendar_id);

  UPDATE public.sticky_notes n
  SET text = p_text, color = p_color, updated_at = now()
  WHERE n.id = p_note_id
  RETURNING * INTO note_row;

  RETURN note_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_update_sticky_note(TEXT, TEXT, UUID, TEXT, TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_update_sticky_note(TEXT, TEXT, UUID, TEXT, TEXT) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_set_sticky_note_struck(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_note_id UUID,
  p_is_struck BOOLEAN
)
RETURNS public.sticky_notes
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  note_row public.sticky_notes%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT * INTO note_row
  FROM public.sticky_notes n
  WHERE n.id = p_note_id
  LIMIT 1;
  IF note_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, note_row.calendar_id);

  UPDATE public.sticky_notes n
  SET is_struck = p_is_struck, updated_at = now()
  WHERE n.id = p_note_id
  RETURNING * INTO note_row;

  RETURN note_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_set_sticky_note_struck(TEXT, TEXT, UUID, BOOLEAN) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_set_sticky_note_struck(TEXT, TEXT, UUID, BOOLEAN) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_move_sticky_note(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_note_id UUID,
  p_date TEXT DEFAULT NULL,
  p_pos_x DOUBLE PRECISION DEFAULT NULL,
  p_pos_y DOUBLE PRECISION DEFAULT NULL,
  p_sort_order INT DEFAULT NULL
)
RETURNS public.sticky_notes
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  note_row public.sticky_notes%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT * INTO note_row
  FROM public.sticky_notes n
  WHERE n.id = p_note_id
  LIMIT 1;
  IF note_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, note_row.calendar_id);

  UPDATE public.sticky_notes n
  SET
    date = p_date,
    pos_x = p_pos_x,
    pos_y = p_pos_y,
    sort_order = COALESCE(p_sort_order, n.sort_order),
    updated_at = now()
  WHERE n.id = p_note_id
  RETURNING * INTO note_row;

  RETURN note_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_move_sticky_note(TEXT, TEXT, UUID, TEXT, DOUBLE PRECISION, DOUBLE PRECISION, INT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_move_sticky_note(TEXT, TEXT, UUID, TEXT, DOUBLE PRECISION, DOUBLE PRECISION, INT) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_update_sticky_note_calendar(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_note_id UUID,
  p_calendar_id UUID
)
RETURNS public.sticky_notes
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  note_row public.sticky_notes%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT * INTO note_row
  FROM public.sticky_notes n
  WHERE n.id = p_note_id
  LIMIT 1;
  IF note_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, note_row.calendar_id);
  PERFORM public._assert_calendar_in_share_link(link_row.id, p_calendar_id);

  UPDATE public.sticky_notes n
  SET calendar_id = p_calendar_id, updated_at = now()
  WHERE n.id = p_note_id
  RETURNING * INTO note_row;

  RETURN note_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_update_sticky_note_calendar(TEXT, TEXT, UUID, UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_update_sticky_note_calendar(TEXT, TEXT, UUID, UUID) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_set_sticky_note_sort_order(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_note_id UUID,
  p_sort_order INT
)
RETURNS public.sticky_notes
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  note_row public.sticky_notes%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT * INTO note_row
  FROM public.sticky_notes n
  WHERE n.id = p_note_id
  LIMIT 1;
  IF note_row.id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, note_row.calendar_id);

  UPDATE public.sticky_notes n
  SET sort_order = p_sort_order, updated_at = now()
  WHERE n.id = p_note_id
  RETURNING * INTO note_row;

  RETURN note_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_set_sticky_note_sort_order(TEXT, TEXT, UUID, INT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_set_sticky_note_sort_order(TEXT, TEXT, UUID, INT) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_delete_sticky_note(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_note_id UUID
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  note_cal UUID;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT n.calendar_id INTO note_cal
  FROM public.sticky_notes n
  WHERE n.id = p_note_id
  LIMIT 1;

  IF note_cal IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, note_cal);

  DELETE FROM public.sticky_notes n
  WHERE n.id = p_note_id;

  RETURN FOUND;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_delete_sticky_note(TEXT, TEXT, UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_delete_sticky_note(TEXT, TEXT, UUID) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_insert_note_connection(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_source_note_id UUID,
  p_target_note_id UUID
)
RETURNS public.note_connections
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  src_cal UUID;
  tgt_cal UUID;
  actor_id UUID;
  conn_row public.note_connections%ROWTYPE;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT calendar_id INTO src_cal FROM public.sticky_notes WHERE id = p_source_note_id LIMIT 1;
  SELECT calendar_id INTO tgt_cal FROM public.sticky_notes WHERE id = p_target_note_id LIMIT 1;

  IF src_cal IS NULL OR tgt_cal IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;
  IF src_cal <> tgt_cal THEN
    RAISE EXCEPTION 'different calendars';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, src_cal);

  actor_id := public._public_share_actor_user_id(link_row.id, src_cal);

  INSERT INTO public.note_connections (user_id, calendar_id, source_note_id, target_note_id)
  VALUES (actor_id, src_cal, p_source_note_id, p_target_note_id)
  RETURNING * INTO conn_row;

  RETURN conn_row;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_insert_note_connection(TEXT, TEXT, UUID, UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_insert_note_connection(TEXT, TEXT, UUID, UUID) TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.public_share_delete_note_connection(
  p_slug TEXT,
  p_password TEXT DEFAULT NULL,
  p_connection_id UUID
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  link_row public.public_share_links%ROWTYPE;
  cal_id UUID;
BEGIN
  link_row := public._assert_public_share_link_access(p_slug, p_password, TRUE);

  SELECT c.calendar_id INTO cal_id
  FROM public.note_connections c
  WHERE c.id = p_connection_id
  LIMIT 1;

  IF cal_id IS NULL THEN
    RAISE EXCEPTION 'not found';
  END IF;

  PERFORM public._assert_calendar_in_share_link(link_row.id, cal_id);

  DELETE FROM public.note_connections c
  WHERE c.id = p_connection_id;

  RETURN FOUND;
END;
$$;

REVOKE ALL ON FUNCTION public.public_share_delete_note_connection(TEXT, TEXT, UUID) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.public_share_delete_note_connection(TEXT, TEXT, UUID) TO anon, authenticated;

-- Backfill existing single-link shares as v2 view-only links.
DO $$
DECLARE
  r RECORD;
  new_id UUID;
BEGIN
  IF to_regclass('public.calendar_public_shares') IS NULL THEN
    RETURN;
  END IF;

  FOR r IN
    SELECT s.*
    FROM public.calendar_public_shares s
    WHERE s.revoked_at IS NULL
  LOOP
    -- Only insert if slug not already present in v2.
    IF EXISTS (SELECT 1 FROM public.public_share_links l WHERE l.slug = r.slug AND l.revoked_at IS NULL) THEN
      CONTINUE;
    END IF;

    INSERT INTO public.public_share_links (slug, permission, password_hash, created_by, created_at, updated_at, revoked_at)
    VALUES (r.slug, 'viewer', r.password_hash, r.created_by, r.created_at, r.updated_at, r.revoked_at)
    RETURNING id INTO new_id;

    INSERT INTO public.public_share_link_calendars (share_link_id, calendar_id)
    VALUES (new_id, r.calendar_id);
  END LOOP;
END $$;
